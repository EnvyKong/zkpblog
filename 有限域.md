零知识证明中所涉及的有限域
======

域是抽象代数的概念，通常这是数学专业才有的课程，但如果只是大致了解其概念和原理的话，其实相对简单，在只考虑平凡算法的情况下。大多数程序员应该都能基于一个大数库（例如`gmp`）用平凡算法实现有限域的基本算法。甚至可以说，在本文所附的参考书的帮助下，大多数程序员应该都能实现有限域的常用优化算法。

从大多数开发者的角度来说，算法的性能以及对算法性能的直观印象是非常重要的。下面在介绍算法的时候，会特别指出其算法复杂度和在真实环境中的实测性能。测试均在我的PC（主频2.4GHz至强处理器）上进行，测试程序都是单线程的，测试数据结果本身不重要，各个数据之间的比例关系才是重要的。如果没有特别指明，测试时所使用的有限域`F(p)`是`libsnark`所使用的`bn254`椭圆曲线上的点所在的值域。测试所使用的有限域库是`libsnark`所使用的`libff`和`libmcl`。由于`libff`和`libmcl`底层使用的正是`gmp`库，所以不再单独测试`gmp`的性能。对于`gmp`，值得一提的是，`gmp`提供3套API，一套是最底层的`mpn`系列[Low-level Functions](https://gmplib.org/manual/Low_002dlevel-Functions.html)，另外一套是上层的`mpz`系列，最后`gmp`还提供了c++封装(`mpz_class`)。`mpn`系列的性能最好，在编写性能敏感的代码时，应该使用这一套`API`。

概念
----

域是一些元素的集合，其上定义了两个算术运算(加法和乘法)，具有常规算术性质，如封闭性、结合律、交换律、分配律、加法零元、乘法单位元、加法逆和乘法逆等。如果集合中的元素个数有限，则称之为有限域。

所谓封闭性，就是两个元素在经过了加法和乘法运算之后，计算结果依然属于集合。结合律、交换律以及分配律属于小学算术的基本概念在此就不再赘述。

域中必须有一个元素称之为加法零元且每个元素都有对应的加法逆元，记作0。任何一个域中的元素a，都有一个与之对应的元素b，使得`a+b=0`（加法零元），很显然，加法零元的加法逆元就是它自身。域中必须有一个元素称之为乘法单位元，记作1，对于任何一个非加法零元的元素`a`，都有一个与之对应的元素`b`，使得`a*b=1`（乘法单位元）。我们能够基于加法逆元和乘法逆元来定义减法和除法。`a-b`就是`a+(-b)`，这里`-b`是`b`的加法逆元。`a/b`就是`a*(1/b)`，`1/b`就是b的乘法逆元。

密码学中通常涉及两种有限域，一种是基于一个大质数`p`取模，通常记作`F(p)`或者`Fp`，也即有限域中的元素为自然数`[0,....p-1]`。域中的两个运算加法和乘法就是先把两个数相加或相乘，然后对`p`取模，加法零元就是自然数0，乘法单位元就是自然数1。另一种是基于`2^n`，通常记作`F(2^n)`，域中的元素为`[0,1,.....2^n-1]`，加法和乘法由多项式算术定义。可以认为`F(2^n)`中的元素是一个n维向量`<x1,x2,x3....xn>`，每个`xi`都是0或者1（也即对2取模），于是可以认为它是一个多项式`x1*x^n-1+x2*x^n-2+....xn`。更多的关于`F(2^n)`的知识（例如多项式算术和不可约多项式）可以自行查看网上的资料[有限域算术](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E5%9F%9F%E7%AE%97%E6%9C%AF)。`F(2^n)`域通常用于对称加密算法场合，椭圆曲线密码学主要使用`F(p)`域。

由于和零知识证明相关的协议和算法基本上都使用`F(p)`域，本文将主要关注`F(p)`域，且只关注和椭圆曲线有关的那些概念和算法。

大数计算
--------

`F(p)`中的`p`通常都是个大质数，例如一个`254bits`的质数，因此很显然涉及到大数的表达和计算。虽然通常都使用已有的成熟的大数库，例如`gmp`和`flint`。但是依然有必要了解一些基本概念和常用计算以及它们的计算开销。如无特殊说明，本文所指算法复杂度均为时间复杂度。

-   大数的表示：不同的库的实现并不一样，最直观的表示方法类似`string`，有一个字段表示长度和符号，最终表示的数`n = b^0 * d[1] + b^1 * d[2] +...`其中b通常是`2^32`或者`2^64`。在有限域场景下，通常并不需要处理负号。

-   加法和减法：类似于小学所讲的平凡算法。很显然，加法和减法的开销是`O(N)`的，N是数字的位长。

-   乘法：小学数学平凡算法的复杂度是`O(N\^2)`。`Knuth`在卷2（半数值算法）中详细讨论了这个问题，并且给出了`O(NLogNLogNLogN)`的算法，这个算法只在非常大的大数（8000\~10000bits，密码学中通常使用的数字远远小于这个值）乘法中才能比传统的O(N\^2)算法具有显著优势。最近有论文声称找到了复杂度为`O(NLogN)`的更快速的算法，但尚未得到广泛使用。基本上可以认为当前密码学中所涉及的乘法的算法复杂度就是`O(N^2)`。

-   平方：基本上都在乘法算法基础上改进，复杂度同样是`O(N^2)`。但由于对称性，使得有一些优化的小技巧，平方速度通常比乘法速度快一倍以上。

-   除法：小学数学的平凡算法下算法复杂度是`O(N^2)`。`Knuth`同样在卷2（半数值算法）中详细讨论了这个问题，做了一些实现方面的优化，但总体而言，并没有改变算法的复杂度。除法的复杂度（`512bits`除以`256bits`得到`256bits`）和乘法（两个`256bits`相乘得到`512bits`）的复杂度几乎是一样的。

-   取模：和除法的算法以及复杂度一样。

域计算
------

-   模加

    也即首先两个数相加，然后再对p取模。百万次模加所需要的时间约为22ms。

-   模减

    可以通过加法逆和模加来实现，很显然有`a-b=a+(-b)`，其中`-b`是`b`的加法逆元。加法逆元可以通过`p-a`获得。模减的速度和模加一样。

-   模乘
   
    也即首先两个数相乘，然后对`p`取模。百万次模乘所需要的时间约为187ms。如果两个数相同，也即平方，那么所需要的时间略少一些。

-   乘法逆和模除

    模除可以通过乘法逆和模乘来实现。很显然有`a/b=a*1/b`，`1/b`就是`b`的乘法逆元。也就是已知`x`，求`y`，使得`x*y=1`。所以核心在于怎么求乘法逆元。通常来说，求乘法逆元有指数法和扩展的欧几里得法。通常扩展欧几里得方法的性能比指数法要好一些，一般都使用欧几里得方法求逆。百万次求逆所需要的时间约为3582ms，可以看出，求逆是一个很慢的操作。

    当需要求一组值的乘法逆元的时候，存在一个很简单优化：例如需要求`a,b,c`的逆，那么可以先计算`x=1/a*b*c`，然后计算`y=x*a`，于是`1/a=x*b*c`，`1/b=y*c`, `1/c=y*b`。当需要求大量的逆时，这个算法的性能提升是非常大的，例如当求百万个有限域的逆时，耗时约从3s降低为200ms，性能提升了15倍以上。

-   指数法求乘法逆

    由于有限域`F(p)`中的所有非0元素和乘法构成一个循环群（证明略），于是，对于域上的任意非0元素`g`，都有`g^(p-1)=1`。很显然有`g*g^(p-2)=g^(p-1)=1`，于是`g`的逆元就是`g^(p-2)`。于是可以利用后面所述的模幂的算法得到乘法逆元。

-   扩展的欧几里得算法求乘法逆

    欧几里得算法又称之为辗转相除法，对于两个整数`a`,`b`，若`a>b`，求取其最大公约数`gcd(a,b)`，有`gcd(a,b)=gcd(b,a%b)`，如此辗转相除就可以得到最大公约数。扩展欧几里得算法指的是：对于不全为0的整数`a,b`，一定存在整数`x`和`y`，使得`ax+by=gcd(a,b)`，当然这里`a`、`b`很可能是个负数。对于`a`、`b`两个数，进行辗转相除法，然后收集辗转相除法中产生的式子，倒回去，就可以得到`ax+by=gcd(a,b)`的整数解。

    以下就是扩展欧几里得算法的一个简单示例，只是用来说明逻辑（gmp库中有高效实现`mpn_gcdext`）：
    ```
    int gcd_recursive(int a, int b, int *x, int *y) {
        if (b == 0) {
           *x = 1, *y = 0;
            return a;
        } else {
            int r = gcd_recursive(b, a % b, x, y); /* r = GCD(a, b) = GCD(b, a%b) */
            int t = *x;
            *x = *y;
            *y = t - a / b * *y;
            return r;
        }
    }
    ```
    回到`F(p)`上来，由于`p`是一个质数，所以很显然，对于任意`g`属于`F(p)`，都有`gcd(g,p)=1`，现在我们要求解`x`，使得`g*x mod p=1`。很显然有`g*x%p=(gx+py)%p=gcd(g,p)=1`。于是，求解`g`的乘法逆元就变成了求解`x`。

-   开方

    后面将会提到椭圆曲线方程为`y^2=ax^3+bx+c`，并且`x`、`y`属于`F(p)`。于是在知道了`x`时，需要开方求`y`。

    很显然对于任意`y`属于`F(p)`，并不一定存在`x`，使得`x*x=y`。如果`x*x%p=y`，那么就称y是模p的二次剩余（平方数），如果不存在这样的`x`，那么就称`y`是模p的二次非剩余（非平方数）。和复数域上的`y=x^2`一样，`F(p)`上的开平方根，也一样有2个解，因为很显然如果`x`是解，那么`-x`（加法逆元）也同样是解（如果0那么只有1个解）。

    在这里不详细介绍具体的算法（《密码学C/C++语言实现10.4.1》），只给出判断一个数是否二次剩余的算法复杂度为`O(LogPLogPLogP)`。

    在已知一个数是二次剩余之后，求解平方根的算法依然非常复杂，并且并没有确定性的算法，只存在搜索算法。目前已知的是，假设`Riemann`假设成立，那么一定能在多项式的时间内找到解。百万次开方所需要的时间是`93s`，可见这是非常非常慢的一个操作。必须特别注意，如果一个数是二次非剩余（非平方数），那么这个算法会可能永远不会返回。算法的证明和细节参看（《密码学C/C++语言实现10.4.2》）。

    一个椭圆曲线上的点可以用点的坐标，也即两个`F(p)`上的数`{x,y}`表示，有一种压缩表示法是只保存`x`，同时用一个位表示`y`的符号（有限域开方也同样有2个解），于是就需要在已知`x`的时候求`y`，就需要用到有限域开方。

    值得一提的是，除了平方根算法之外，给定有限域中的任意`a`，方程`x^a=b`都存在有效的算法，具体方法请参看《计算数论》2.4.5。由此产生了一个问题，对于以向量`a`为系数的有限域内的方程`a[i]*x^i+a[i-1]*x^(i-1)+.....+a[1]*x+a[0]=0`，是否存在有效的求解方法？这个问题我也不知道确切答案，我倾向于认为对于不是那么大的`i`，例如`i=1000,000`，存在有效的求解方法。

-   模幂

    很显然求指数可以转换为O(LogN)次的乘法或模乘，例如求`g^9`：
    ```
      auto g1 = (g * g) % p
      auto g2 = (g1 * g1) % p
      auto g3 = (g2 * g2) % p
      auto g4 = (g3 * g) % p
    ```
    以下是一个示范实现：
    ```
    template<typename FieldT, mp_size_t m>
        FieldT power(const FieldT &base, const bigint<m> &exponent) {
      FieldT result = FieldT::one();
      bool found_one = false;
      for (int64_t i = (int64_t)exponent.max_bits() - 1; i >= 0; --i) {
        if (found_one) {
          result = result * result;
        }
        if (exponent.test_bit(i)) {
          found_one = true;
          result = result * base;
        }
      }
      return result;
    }
    ```
    由于模运算可以将所有中间结果和最后结果限制在一个范围内，对于一个`k`位的模数`p`，任何加减乘除的中间结果将不会超过`2k`位长，因此在计算大数模幂的时候通常会考虑结合模运算分解幂过程，防止计算过程产生大数中间值从而发生溢出等错误的情况。如果不这么做的话，即便使用的大数库支持任意长度的大数运算，在计算过程中如果不适当的处理，也会产生巨大的中间值从而耗费内存和耗费CPU。这种算法称为加法链，或二进制平方和乘法方法。

-   Montgomery约简

    前面所提到的有限域算法对于大多数程序员来说可以当作是一个黑盒，因为通常可以直接调用库里的实现。但是下面介绍的Montgomery约简则不同，这个算法改变了一个有限域值的内存状态，因此需要额外关注，至少需要理解其大致原理，否则阅读代码（例如`libff`）的时候将会感觉到困惑。

    前面提到基于加法链的有限域模幂算法。加法链算法需要在每一步都进行模乘，例如两个`254bits`的数相乘结果是一个`508bits`的数，`508bits`的数去模一个`254bits`的数（`p`），Montgomery约简的目的就是消除在每次整数相乘之后都有的取模操作。

    考虑这么一个事实：模一个大质数`p`是麻烦的，但是模一个`2^k`是非常轻量的(只需要移位就行了)。对于`F(p)`，令`r=2^64`（假设`p`大于`64bits`，通常`p`会是`254bits`甚至更大），`r^(-1)`是`r`模`p`的乘法逆元，`p^(-1)`是`p`模`r`的乘法逆元，定义`p'=-(p^(-1)) mod r，m=tp' mod r`，于是对于整数`t`，有 `(t+mp)/r = t*r^(-1) mod p`。

    在这里略过对上面这个等式的证明。注意同余式的左边，我们进行了模`r`同余和除以`r`（注意`t+mq mod r`总是0，也即除法没有余数）的运算，但是没有进行模`p`的同余计算。因为`r`是`2^64`，我们可以轻易的进行除`r`的运算。于是上面这个等式左边需要的计算开销明显比右边少，这就是Montgomery约简的本质所在。

    为了应用Montgomery约简，我们将模`p`的计算转移到一个完全剩余系。把原来`F(p)`中的元素x映射到`x*r % p`来进行计算。也即`R:=R(r,p):={xr mod p, 0<=x<n}`。接下来定义两个`R`中数字`a`和`b`的Montgomery乘积，`a*b:=abr^(-1) mod p`。`r^(-1)`表示`r`模`p`的乘法逆元。很显然有`a*b=(xr)(yr)r^(-1)=(xy)r mod p`。因此对`R`的成员进行乘的结果依旧在`R`中。

    注意这里的`r^(-1)`是`r`模`p`的乘法逆元，`p^(-1)`是`p`模`r`的乘法逆元。由于`p`是个一个质数，`r`是`2^64`，所以很显然有`gcd(r,p)=1`，于是这两个逆元都可以用前面所述的方法计算得到。由于只需要计算一次，所以无所谓用指数法还是扩展的欧几里得法。如果用扩展的欧几里得法，则有`1=r'*r-p'p`，可以一次求出`r'`和`p'`。

    最后总结一下，有限域的数`a`转为Montgomery表示的方式为`a'=a*r`。转换之后，`a*b mod p`的计算变成了`MontgomeryMul(a',b')`，也即`a'*b'*r^(-1)`，具体的计算方式（伪代码）为：
    ```
    FieldT MontgomeryMul(FieldT const& a, FieldT const& b) {
        auto t=a.as_bigin()*b.as_bigint(); // t is a 512bits big int
        auto m=t * p' %r;
        auto u=(t+mp)/r;
        return (u>p)? u-p:u;
    }    
    ```

    以上算法中，第一行需要进行一次大数相乘，第三行的`/r`如前所述，正好能整除。第二行和第三行由于r是`2^64`，开销可以忽略不计。详细的算法可以参考[应用密码学第一版14.32](http://cacr.uwaterloo.ca/hac/about/chap14.pdf)。

    于是，普通算法是一次乘法，一次取模(`a*b%p`)，使用Montgomery约简之后，开销约等于一次乘法。算法复杂度降低了一倍。如果要把Montgomery值`a'`转换回有限域`a`，那么只需要乘以`r^(-1)`即可，从实现的角度，可以直接让a’和1做一次`MontgomeryMul`。Montgomery对于有限域的计算的优化是巨大的（提高100%），以至于它在几乎所有的有限域实现中，都不是编译可选项，而是内置实现。

    百万次指数运算，所需要的时间约为61s。

基于有限域的离散对数（DLP）问题
-------------------------------

前面介绍了有限域上的各种运算以及复杂度，我们已经知道，有限域`F(p)`的模幂，也即计算`y=x^a`，可以通过`O(LogN)`次模乘实现。但是，知道`y`和`x`，要求出`a`来是非常困难的，这被称之为有限域上的离散对数问题，通常认为这是一个非常困难的问题，甚至是一般情况下也比整数质因数分解难得多（`RSA`所依赖的困难问题）。

`F(p)`去掉零元，剩下的元素可以构成一个有限循环群，群的阶，也即群内的元素个数为`p-1`，`p`是一个质数，所以很显然`p-1`是一个合数，介绍完这个基本概念之后，下面来介绍已有的攻击方法。

目前使用的计算离散对数的算法本质上可以分为三类：

-   对任何有限域都适用的算法，即算法并不利用群的任何特殊性质。`Shanks`的小步-大步法就是这种算法的代表。这种算法的时间复杂度通常是`O(p)`。

-   这类算法是针对这种类型的群：群中的元素可由一个相对小的集合中元素的乘积表示，这个集合称为因子基，这类算法代表性的算法是具有各种形式的指数演算法，数域筛法就属于这类算法。这种算法的时间复杂度是`O(exp(c(Log(p)LogLog(p))))`，这里`c`是个常数。

-   对于阶没有大的质因子的有限群有效的算法。更具体的说，适用于`p-1`没有大的质因子的情况。基于中国剩余定理的`Silver-Pohlig-Hellman`算法就属于这类算法。这种算法的时间复杂度通常是`O(q^1/2)`，`q`是`p-1`的最大质因子。


    算法的具体原理和细节不在这里详细介绍，可以看出，当`p`很大的时候，第一种和第二种算法的时间复杂度都太大，以至于计算是完全不可行的。第三种算法可以把`O(p)`复杂度约简到`O(q)`，因此最终破解难度取决于`p-1`的最大质因数`q`。甚至还存在一种优化的算法，可以进一步把复杂度降低为`O(q^1/2)`。因此在选择有限域参数时，这是一个必须关注的问题。

有限域的DLP问题最多的使用场景是密钥交换。下面简要的叙述一下过程：

1.  `A`、`B`双方约定或由协议规定一个`F(p)`有限域，并约定或规定一个域中的随机元素`g`。

2.  `A`随机选择一个域中的非0元素`c`，发送`g^c`给B，作为公钥；这里的`g^c`指有限域中的模幂，也即`g^c mod p`。下面的指数运算也都指模幂。

3.  `B`随机选择一个域中的非0元素`d`，发送`g^d`给`A`。

4.  此时`A`、`B`双方都能计算`K=(g^c)^d=(g^d)^c=(g^cd mod p)`，即`K`即为`A`、`B`之间的密钥。

这种方式能在`A`、`B`事先没有任何约定的情况下安全的协商密钥，并且可以抵御窃听攻击。窃听者得到`g^c`和`g^d`之后并没有意义，它无法计算出`g^cd`。

值得特别说明的是，这种方式无法抵御中间人攻击。中间人可以对`A`伪造自己是`B`，对`B`伪造自己是`A`，从而劫持整个会话。为了解决这个问题，通常协商密钥时，还要用发送者的私钥对消息`g^c`进行签名（例如`ipsec`协议的密钥协商过程）。

域的扩张
-------------------------------

某些零知识证明体制中使用了椭圆曲线配对（ECC Pairing），比如[BCGTV13](http://eprint.iacr.org/2012/718)，[Groth16](https://eprint.iacr.org/2016/260)。域的扩张是无法绕开的一个基础性概念，因此有必要介绍一下。

可以通过一个次数为`m(m>1)`的不可约多项式将一个域扩张为一个更大的域，例如将`F(p)`域扩张为`F(p^m)`域。最典型的扩张就是将实数域`R`扩张为复数域`C`。

某些实数域`R`上的多项式例如`x^2+1=0`不能因式分解为多个`R`上的一次多项式之积，我们称`x^2+1=0`为R上的2次不可约多项式。基于这个多项式，我们来定义一个扩张域，也即复数域，域中的元素是次数小于2的多项式（`ax+b`，由两个R里的元素构成，也可以表示为`{a,b}`），且多项式乘法是模`x^2+1=0`的余数：`(ax+b)(cx+d)=acx^2+adx+bcx+bd`。这个多项式用长除法除以`x^2+1`，得到`(ad+bc)x+(bd-ac)`。或者用另一种方式：由于`x^2+1=0`，`(ax+b)(cx+d)=acx^2+adx+bcx+bd=(ad+bc)x+(bd-ac)`。如果x用常用符号`i=(-1)^1/2`代替，就成了复数常简的乘法定义。采用这种方式，复数域被定义为`C=R[x]/<x^2+1>`。

只要`F(p)`上存在`m`次不可约多项式`p(x)`，`F(p)`就可以扩展为更大的有限域`F(p^m)`。`F(p^m)`的每个元素由`m`个`F(p)`组成，是一个`m-1`阶多项式。加法是多项式的普通加法，乘法则是多项式的模`p(x)`乘法。比如实数域`R`上存在不可约多项式`x^2+1=0`，基于此不可约多项式扩域得到了复数域（很显然还存在无数不可约多项式例如`x^2+2=0`或者`x^2+2x+2=0`，同样可以基于新的不可约多项式进行扩域）。复数域`C`上不存在这种不可约多项式（很显然复数域上的任意多项式的根都属于复数域），因此复数域不能通过这种方式扩域。需要指出的是，每个有限域`F(p)`上都存在任意次数的不可约多项式（证明过程略，读者可以自行查看任意一本抽象代数的教科书）。

最后总结一下，扩张域`F(p^m)<p(x)>`包括两个部分：基域`F(p)`和`F(p)`上的`m`阶的不可约多项式`p(x)`。扩张域中的加法是多项式加法，乘法是多项式乘法之后模`p(x)`。定义了加法和乘法之后，我们同样可以基于和基域`F(p)`相同的算法实现求逆和开方等运算。

参考书籍
--------

讨论有限域的书很多，除了抽象代数等数学教科书之外，密码学方面的书籍通常也都涉及大量有限域的内容，但是这些书通常原理讲的多，算法讲的少，在此特别推荐两本深入探讨有限域相关算法和实现的书。

-   密码学C/C++语言实现 （`Cryptography in C and C++`） `Michael Welsehenbach` 机械工业出版社

-   计算数论（`Number Theory for Computing`） `颜松远` 清华大学出版社
